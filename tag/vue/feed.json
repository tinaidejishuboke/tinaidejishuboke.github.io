{
    "version": "https://jsonfeed.org/version/1",
    "title": "路宇航的博客 • All posts by \"vue\" tag",
    "description": "",
    "home_page_url": "https://github.com/tinaidejishuboke/tinaidejishuboke.github.io",
    "items": [
        {
            "id": "https://github.com/tinaidejishuboke/tinaidejishuboke.github.io/2020/08/13/vue%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5/",
            "url": "https://github.com/tinaidejishuboke/tinaidejishuboke.github.io/2020/08/13/vue%E6%8B%A6%E6%88%AA%E5%99%A8%E7%9A%84%E6%A6%82%E5%BF%B5/",
            "title": "vue拦截器的概念",
            "date_published": "2020-08-13T07:18:19.000Z",
            "content_html": "<h2 id=\"一-拦截器的基本介绍\"><a class=\"markdownIt-Anchor\" href=\"#一-拦截器的基本介绍\">#</a> 一、拦截器的基本介绍</h2>\n<ul>\n<li>什么是拦截器:\n<ul>\n<li>想拦截住我们的请求过程<br>\n比如你想在请求前做一些事情，拦截请求，等这件事做完之后再去请求<br>\n或者是要等请求结束之后做一些事情，再返回数据，可以拦截处理之后再返回</li>\n</ul>\n</li>\n<li>拦截器的作用:\n<ul>\n<li>一般来说，像数据交互之类的都要用到不同的身份验证，比如登录 token 验证，验证用户<br>\n是否登录，如果没有登录，该用户就不能操作登录之后的内容，这就是拦截器的作用</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"二-拦截器的分类\"><a class=\"markdownIt-Anchor\" href=\"#二-拦截器的分类\">#</a> 二、拦截器的分类</h2>\n<p>请求拦截器和响应拦截器 / 路由拦截器<br>\n <code>PS:一般在请求拦截器中增加标识token或其他请求配置，在响应拦截器中对统一错误或状态码进行处理</code> <br>\n① axios 提供了拦截请求的功能，可以在发出请求前进行操作，例如统一为所有的请求添加 token 头信息。<br>\n② axios 提供了拦截响应的功能，可以在处理响应前进行操作，例如统一处理 401 身份认证错误。</p>\n<h2 id=\"三-代码演示\"><a class=\"markdownIt-Anchor\" href=\"#三-代码演示\">#</a> 三、代码演示</h2>\n<h4 id=\"路由拦截器-通过路由进行判断\"><a class=\"markdownIt-Anchor\" href=\"#路由拦截器-通过路由进行判断\">#</a> 路由拦截器：通过路由进行判断</h4>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\">&#x2F;&#x2F;to表示要去的路由指向，from是指从哪个路由跳转过来的，next是判断操作</span><br><span class=\"line\">&#x2F;&#x2F; 配置全局的vue路由拦截器  导航守卫(路由守卫)</span><br><span class=\"line\">router.beforeEach((to, from, next) &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(to)</span><br><span class=\"line\">        &#x2F;&#x2F; 判断 是否是跳转到 admin页 如果是则必须登录才能跳转</span><br><span class=\"line\">    if (to.path in [&quot;&#x2F;路由地址&quot;,&quot;&#x2F;...&quot;,&quot;&#x2F;...&quot;])&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;判断 是否登录</span><br><span class=\"line\">        const token &#x3D; sessionStorage.getItem(&quot;token&quot;)</span><br><span class=\"line\">        if (!token) &#123;</span><br><span class=\"line\">            alert(&quot;没有登录，不能操作&quot;)</span><br><span class=\"line\">                &#x2F;&#x2F;跳转到登录页</span><br><span class=\"line\">            next(&quot;&#x2F;login?back&#x3D;&quot; + to.fullPath)</span><br><span class=\"line\">            return</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;放行</span><br><span class=\"line\">    next()</span><br><span class=\"line\">&#125;)  </span><br></pre></td></tr></table></figure>\n<h4 id=\"request请求拦截器-在请求发送前进行一些操作\"><a class=\"markdownIt-Anchor\" href=\"#request请求拦截器-在请求发送前进行一些操作\">#</a> request 请求拦截器：在请求发送前进行一些操作</h4>\n<p>在 main.js 中<br>\n import axios from ‘axios’ // 引入 axios<br>\nVue.prototype.$http = axios // 配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\">&#x2F;&#x2F; 添加请求拦截器</span><br><span class=\"line\">axios.interceptors.request.use(config &#x3D;&gt; &#123;</span><br><span class=\"line\">  let token &#x3D; localStorage.getItem(&#39;token&#39;);</span><br><span class=\"line\">  if (token) &#123;</span><br><span class=\"line\">     config.headers.token &#x3D; token &#x2F;&#x2F;把token放在请求头中（headers是对象类型）</span><br><span class=\"line\">     &#x2F;&#x2F; 如果后端使用了rest framework jwt，如下：</span><br><span class=\"line\">   &#x2F;&#x2F;config.headers.common[&#39;Authorization&#39;] &#x3D; &#39;jwt &#39; + token &#x2F;&#x2F; 头部设置</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return config;</span><br><span class=\"line\">&#125;, error &#x3D;&gt; &#123;</span><br><span class=\"line\">  console.log(error) &#x2F;&#x2F;打印错误信息</span><br><span class=\"line\">  return Promise.reject(error);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"response响应拦截器-在接收到响应后进行一些操作\"><a class=\"markdownIt-Anchor\" href=\"#response响应拦截器-在接收到响应后进行一些操作\">#</a> response 响应拦截器：在接收到响应后进行一些操作</h4>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\">&#x2F;&#x2F; 响应拦截器（在响应时自动会做的操作）</span><br><span class=\"line\">axios.interceptors.response.use(response &#x3D;&gt; &#123;</span><br><span class=\"line\">　　return response &#x2F;&#x2F; 成功直接返回</span><br><span class=\"line\">&#125;, error &#x3D;&gt; &#123;</span><br><span class=\"line\">  console.log(error.request) &#x2F;&#x2F; 打印错误信息</span><br><span class=\"line\">&#x2F;&#x2F;处理错误信息</span><br><span class=\"line\">  if (error.request.status &#x3D;&#x3D;&#x3D; 400)&#123;  &#x2F;&#x2F; 400错误的状态码</span><br><span class=\"line\">    window.location.href &#x3D; &quot;&#x2F;&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return error </span><br><span class=\"line\">&#x2F;&#x2F;返回错误信息</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>",
            "tags": [
                "Vue"
            ]
        },
        {
            "id": "https://github.com/tinaidejishuboke/tinaidejishuboke.github.io/2020/04/13/vue%E4%B8%ADwebsocket%E5%92%8Chttp%E7%9A%84%E5%8C%BA%E5%88%AB/",
            "url": "https://github.com/tinaidejishuboke/tinaidejishuboke.github.io/2020/04/13/vue%E4%B8%ADwebsocket%E5%92%8Chttp%E7%9A%84%E5%8C%BA%E5%88%AB/",
            "title": "vue中websocket和http的区别",
            "date_published": "2020-04-13T07:20:24.000Z",
            "content_html": "<h2 id=\"什么是websocket\"><a class=\"markdownIt-Anchor\" href=\"#什么是websocket\">#</a> 什么是 Websocket</h2>\n<ul>\n<li>Websocket 是一种网络通信协议，是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议</li>\n</ul>\n<h2 id=\"websocket有什么特点\"><a class=\"markdownIt-Anchor\" href=\"#websocket有什么特点\">#</a> Websocket 有什么特点</h2>\n<ul>\n<li>建立在 TCP 协议之上</li>\n<li>性能开销小通信高效</li>\n<li>协议标识符 ws wss（加密之后）</li>\n<li>持久化网络通信协议</li>\n<li>客户端可以与任意服务器通信</li>\n</ul>\n<h2 id=\"websocket是什么样的协议具体有什么优点\"><a class=\"markdownIt-Anchor\" href=\"#websocket是什么样的协议具体有什么优点\">#</a> Websocket 是什么样的协议，具体有什么优点</h2>\n<blockquote>\n<p>首先，Websocket 是一个持久化的协议，相对于 HTTP 这种非持久的协议来说<br>\n HTTP 的生命周期通过 Request 来界定，也就是一个 Request 一个 Response ，那么在 HTTP1.0 中，这次 HTTP 请求就结束了。<br>\n在 HTTP1.1 中进行了改进，使得有一个 keep-alive，也就是说，在一个 HTTP 连接中，可以发送多个 Request，接收多个 Response。但是请记住 Request = Response ， 在 HTTP 中永远是这样，也就是说一个 request 只能有一个 response。而且这个 response 也是被动的，不能主动发起。</p>\n</blockquote>\n<h2 id=\"websocket的作用\"><a class=\"markdownIt-Anchor\" href=\"#websocket的作用\">#</a> Websocket 的作用</h2>\n<h3 id=\"1ajax轮询\"><a class=\"markdownIt-Anchor\" href=\"#1ajax轮询\">#</a> 1）ajax 轮询</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ajax轮询的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息</span><br></pre></td></tr></table></figure>\n<h3 id=\"2long-poll长轮询\"><a class=\"markdownIt-Anchor\" href=\"#2long-poll长轮询\">#</a> 2）long poll 长轮询</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long poll 其实原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端（对于PHP有最大执行时间，建议没消息，执行到一定时间也返回）。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。</span><br><span class=\"line\">从上面可以看出其实这两种方式，都是在不断地建立HTTP连接，关闭HTTP协议，由于HTTP是非状态性的，每次都要重新传输 identity info （鉴别信息），来告诉服务端你是谁。然后等待服务端处理，可以体现HTTP协议的另外一个特点，被动性。</span><br><span class=\"line\">何为被动性呢，其实就是，服务端不能主动联系客户端，只能有客户端发起。从上面很容易看出来，不管怎么样，上面这两种都是非常消耗资源的。</span><br><span class=\"line\">ajax轮询 需要服务器有很快的处理速度和资源。（速度）long poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小）</span><br></pre></td></tr></table></figure>\n<h3 id=\"3websocket\"><a class=\"markdownIt-Anchor\" href=\"#3websocket\">#</a> 3）WebSocket</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Websocket解决了HTTP的这几个难题。首先，被动性，当服务器完成协议升级后（HTTP-&gt;Websocket），服务端就可以主动推送信息给客户端啦。解决了上面同步有延迟的问题。</span><br><span class=\"line\">解决服务器上消耗资源的问题：其实我们所用的程序是要经过两层代理的，即HTTP协议在Nginx等服务器的解析下，然后再传送给相应的Handler（php等）来处理。简单地说，我们有一个非常快速的 接线员（Nginx） ，他负责把问题转交给相应的 客服（Handler） 。Websocket就解决了这样一个难题，建立后，可以直接跟接线员建立持久连接，有信息的时候客服想办法通知接线员，然后接线员在统一转交给客户。</span><br><span class=\"line\">由于Websocket只需要一次HTTP握手，所以说整个通讯过程是建立在一次连接&#x2F;状态中，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议，还要查看identity info的信息。</span><br><span class=\"line\">目前唯一的问题是：不兼容低版本的IE</span><br></pre></td></tr></table></figure>\n<h2 id=\"websocket使用场景\"><a class=\"markdownIt-Anchor\" href=\"#websocket使用场景\">#</a> Websocket 使用场景</h2>\n<blockquote>\n<p>社交聊天、弹幕、多玩家游戏、视频会议 / 聊天、在线教育、智能家居等需要高实时的场景</p>\n</blockquote>\n<h2 id=\"websocket-四个事件两个方法\"><a class=\"markdownIt-Anchor\" href=\"#websocket-四个事件两个方法\">#</a> Websocket 四个事件，两个方法</h2>\n<ul>\n<li>\n<h3 id=\"4个事件\"><a class=\"markdownIt-Anchor\" href=\"#4个事件\">#</a> 4 个事件</h3>\n<ul>\n<li>open Socket.onopen 连接建立时触发</li>\n<li>message Socket.onmessage 客户端接收服务端数据时触发</li>\n<li>error Socket.onerror 通信发生错误时触发</li>\n<li>close Socket.onclose 连接关闭时触发</li>\n</ul>\n</li>\n<li>\n<h3 id=\"2个方法\"><a class=\"markdownIt-Anchor\" href=\"#2个方法\">#</a> 2 个方法</h3>\n<ul>\n<li>Socket.send () 使用连接发送数据</li>\n<li>Socket.close () 关闭连接</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"什么是http协议\"><a class=\"markdownIt-Anchor\" href=\"#什么是http协议\">#</a> 什么是 HTTP 协议</h2>\n<ul>\n<li>超文本传输协议，本质上是一种通信协议。用来将 html 从服务端传送到客户端</li>\n</ul>\n<h2 id=\"特点\"><a class=\"markdownIt-Anchor\" href=\"#特点\">#</a> 特点</h2>\n<ul>\n<li>\n<p>简单快速</p>\n<blockquote>\n<p>客户向服务器请求服务时，只需传送请求方法和路径</p>\n</blockquote>\n</li>\n<li>\n<p>无连接</p>\n<blockquote>\n<p>限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间</p>\n</blockquote>\n</li>\n<li>\n<p>无状态</p>\n<blockquote>\n<p>协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快</p>\n</blockquote>\n</li>\n</ul>\n<hr>\n<h2 id=\"websocket与http的关系\"><a class=\"markdownIt-Anchor\" href=\"#websocket与http的关系\">#</a> Websocket 与 http 的关系</h2>\n<ul>\n<li>\n<h3 id=\"相同点\"><a class=\"markdownIt-Anchor\" href=\"#相同点\">#</a> 相同点</h3>\n<ol>\n<li>都是一样基于 TCP 的，都是可靠性传输协议。</li>\n<li>都是应用层协议。</li>\n</ol>\n</li>\n<li>\n<h3 id=\"不同点\"><a class=\"markdownIt-Anchor\" href=\"#不同点\">#</a> 不同点</h3>\n<ol>\n<li>WebSocket 是双向通信协议，模拟 Socket 协议，可以双向发送或接受信息。HTTP 是单向的。</li>\n<li>WebSocket 是需要浏览器和服务器握手进行建立连接的。而 http 是浏览器发起向服务器的连接，服务器预先并不知道这个连接。</li>\n</ol>\n</li>\n</ul>\n<hr>\n<h2 id=\"websocket实例\"><a class=\"markdownIt-Anchor\" href=\"#websocket实例\">#</a> Websocket 实例</h2>\n<ul>\n<li>\n<h3 id=\"安装\"><a class=\"markdownIt-Anchor\" href=\"#安装\">#</a> 安装</h3>\n<ul>\n<li>pip install -i <span class=\"exturl\" data-url=\"aHR0cHM6Ly9weXBpLnR1bmEudHNpbmdodWEuZWR1LmNuL3NpbXBsZQ==\">https://pypi.tuna.tsinghua.edu.cn/simple</span> dwebsocket</li>\n</ul>\n</li>\n<li>\n<h3 id=\"定义视图文件的逻辑viewspy\"><a class=\"markdownIt-Anchor\" href=\"#定义视图文件的逻辑viewspy\">#</a> <span class=\"exturl\" data-url=\"aHR0cDovL3huLS12aWV3cy14czFobDRiNnoxYm55amM0eTR3NmJna3ljN3pwOGZjLnB5\">定义视图文件的逻辑 views.py</span></h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PYTHON</span><br><span class=\"line\">#导入websocket装饰器</span><br><span class=\"line\">from dwebsocket.decorators import accept_websocket</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#接收前端信息</span><br><span class=\"line\">@accept_websocket</span><br><span class=\"line\">def test_socket(request):</span><br><span class=\"line\">    if request.is_websocket():</span><br><span class=\"line\">        for message in request.websocket:</span><br><span class=\"line\">            c&#x3D;str(message,encoding&#x3D;&#39;utf-8&#39;)</span><br><span class=\"line\">            print(c)</span><br><span class=\"line\">            request.websocket.send(message)</span><br><span class=\"line\"></span><br><span class=\"line\">#主动推送消息</span><br><span class=\"line\">@accept_websocket</span><br><span class=\"line\">def test_websocket(request):</span><br><span class=\"line\">    if request.is_websocket():</span><br><span class=\"line\">        while 1:</span><br><span class=\"line\">            time.sleep(1) ## 向前端发送时间</span><br><span class=\"line\">            dit &#x3D; &#123;</span><br><span class=\"line\">                &#39;time&#39;:time.strftime(&#39;%Y.%m.%d %H:%M:%S&#39;,time.localtime(time.time()))</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            request.websocket.send(json.dumps(dit))</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<h3 id=\"路由配置\"><a class=\"markdownIt-Anchor\" href=\"#路由配置\">#</a> 路由配置</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PYTHON</span><br><span class=\"line\">#websocket</span><br><span class=\"line\">path(&#39;test_socket&#39;,test_socket),</span><br><span class=\"line\">path(&#39;test_websocket&#39;,test_websocket),</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<h3 id=\"定义前端发送消息的页面-socketvue\"><a class=\"markdownIt-Anchor\" href=\"#定义前端发送消息的页面-socketvue\">#</a> 定义前端发送消息的页面 – socket.vue</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CODE</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">  &lt;div&gt;</span><br><span class=\"line\">    &lt;input id&#x3D;&quot;chat-message-input&quot; type&#x3D;&quot;text&quot; size&#x3D;&quot;100&quot;&#x2F;&gt;&lt;br&#x2F;&gt;</span><br><span class=\"line\">    &lt;input id&#x3D;&quot;chat-message-submit&quot; type&#x3D;&quot;button&quot; value&#x3D;&quot;Send&quot; @click&#x3D;&#39;sendmessage()&#39;&#x2F;&gt;</span><br><span class=\"line\">  &lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;socket&quot;,</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;&#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    sendmessage() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">      window.s.send(document.getElementById(&quot;chat-message-input&quot;).value);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;生成socket对象</span><br><span class=\"line\">    var socket &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;127.0.0.1:8000&#x2F;z&#x2F;test_socket&#x2F;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    socket.onopen &#x3D; function () &#123;</span><br><span class=\"line\">      console.log(&#39;WebSocket open&#39;);&#x2F;&#x2F;成功连接上Websocket</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    socket.onmessage &#x3D; function (e) &#123;</span><br><span class=\"line\">      console.log(&#39;message: &#39; + e.data);&#x2F;&#x2F;打印服务端返回的数据</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    socket.onclose &#x3D; function (e) &#123;</span><br><span class=\"line\">      console.log(e);</span><br><span class=\"line\">      socket.close(); &#x2F;&#x2F;关闭TCP连接</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    if (socket.readyState &#x3D;&#x3D; WebSocket.OPEN) &#123;</span><br><span class=\"line\">      socket.onopen();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    window.s &#x3D; socket;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style scoped&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<h3 id=\"然后再定义一个页面测试后台的主动推送-socket_pushvue\"><a class=\"markdownIt-Anchor\" href=\"#然后再定义一个页面测试后台的主动推送-socket_pushvue\">#</a> 然后再定义一个页面，测试后台的主动推送 – socket_push.vue</h3>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PYTHON</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  name: &quot;socket_push&quot;,</span><br><span class=\"line\">  data() &#123;</span><br><span class=\"line\">    return &#123;&#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  mounted() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;生成socket对象</span><br><span class=\"line\">    var socket &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;127.0.0.1:8000&#x2F;z&#x2F;test_websocket&#x2F;&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    socket.onopen &#x3D; function () &#123;</span><br><span class=\"line\">      console.log(&#39;WebSocket open&#39;);&#x2F;&#x2F;成功连接上Websocket</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    socket.onmessage &#x3D; function (e) &#123;</span><br><span class=\"line\">      console.log(&#39;message: &#39; + e.data);&#x2F;&#x2F;打印服务端返回的数据</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    socket.onclose &#x3D; function (e) &#123;</span><br><span class=\"line\">      console.log(e);</span><br><span class=\"line\">      socket.close(); &#x2F;&#x2F;关闭TCP连接</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    if (socket.readyState &#x3D;&#x3D; WebSocket.OPEN) &#123;</span><br><span class=\"line\">      socket.onopen();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;style scoped&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n",
            "tags": [
                "Vue"
            ]
        },
        {
            "id": "https://github.com/tinaidejishuboke/tinaidejishuboke.github.io/2019/09/13/vue%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/",
            "url": "https://github.com/tinaidejishuboke/tinaidejishuboke.github.io/2019/09/13/vue%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0/",
            "title": "vue钩子函数",
            "date_published": "2019-09-13T07:16:54.000Z",
            "content_html": "<h2 id=\"一-路由钩子函数相关概念\"><a class=\"markdownIt-Anchor\" href=\"#一-路由钩子函数相关概念\">#</a> 一、路由钩子函数相关概念</h2>\n<ul>\n<li>什么情况下要使用路由的钩子函数？\n<ul>\n<li>在路由跳转的时候，我们需要一些权限判断或者其他操作，这个时候就需要使用路由的钩子函数</li>\n</ul>\n</li>\n<li>路由钩子函数的定义:\n<ul>\n<li>路由钩子主要是给使用者在路由发生变化时进行一些特殊的处理而定义的函数</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"二-路由钩子的分类\"><a class=\"markdownIt-Anchor\" href=\"#二-路由钩子的分类\">#</a> 二、路由钩子的分类</h2>\n<h4 id=\"1-全局路由钩子\"><a class=\"markdownIt-Anchor\" href=\"#1-全局路由钩子\">#</a> 1、全局路由钩子</h4>\n<blockquote>\n<p>在初始化 VueRouter 以后，直接使用 router 实例进行注册<br>\n包括两个钩子：beforeEach、afterEach（每个路由切换前或者切换后调用）</p>\n</blockquote>\n<h4 id=\"2-单个路由钩子\"><a class=\"markdownIt-Anchor\" href=\"#2-单个路由钩子\">#</a> 2、单个路由钩子</h4>\n<blockquote>\n<p>写在路由配置中，只有访问到这个路径，才能触发钩子函数<br>\n包括两个钩子：beforeEnter、beforeLeave</p>\n</blockquote>\n<h4 id=\"3-组件内路由钩子\"><a class=\"markdownIt-Anchor\" href=\"#3-组件内路由钩子\">#</a> 3、组件内路由钩子</h4>\n<blockquote>\n<p>这个钩子要在组件内定义<br>\n包括三个钩子：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</p>\n</blockquote>\n<hr>\n<p>（1） 路由对象是在使用 vue-route 启动应用时，每个匹配的组件实例都会被注入 router 的对象，称之为路由对象。<br>\n在组件内部可以通过 this.$route 的方式调用<br>\n（2）路由对象有： $route.path , $route.params, $route.query, $route.router 等属性</p>\n<h2 id=\"三-代码演示\"><a class=\"markdownIt-Anchor\" href=\"#三-代码演示\">#</a> 三、代码演示</h2>\n<ul>\n<li>\n<h3 id=\"全局路由钩子\"><a class=\"markdownIt-Anchor\" href=\"#全局路由钩子\">#</a> 全局路由钩子</h3>\n<ul>\n<li>\n<h4 id=\"routerbeforeeachtofromnext-全局前置守卫\"><a class=\"markdownIt-Anchor\" href=\"#routerbeforeeachtofromnext-全局前置守卫\">#</a> router.beforeEach（（to,from,next）=&gt;{ }）：全局前置守卫</h4>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\">router.beforeEach(function (to,from,next) &#123;</span><br><span class=\"line\">  console.log(to);  &#x2F;&#x2F;到达的路由</span><br><span class=\"line\">  console.log(next);&#x2F;&#x2F;跳转到其他路由</span><br><span class=\"line\">  console.log(from);&#x2F;&#x2F;离开的路由</span><br><span class=\"line\">  next();</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<h4 id=\"routeraftereachtofrom-全局后置钩子\"><a class=\"markdownIt-Anchor\" href=\"#routeraftereachtofrom-全局后置钩子\">#</a> router.afterEach（（to,from）=&gt;{ }）：全局后置钩子</h4>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\">router.afterEach(function (to,from) &#123;</span><br><span class=\"line\">  console.log(to);  &#x2F;&#x2F;到达的路由</span><br><span class=\"line\">  console.log(from);&#x2F;&#x2F;离开的路由</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<h3 id=\"单个路由钩子\"><a class=\"markdownIt-Anchor\" href=\"#单个路由钩子\">#</a> 单个路由钩子</h3>\n<ul>\n<li>\n<h4 id=\"beforeenter\"><a class=\"markdownIt-Anchor\" href=\"#beforeenter\">#</a> beforeEnter</h4>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\">export default new Router (&#123;</span><br><span class=\"line\">    routes: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            path: &#39;&#x2F;index&#39;,</span><br><span class=\"line\">            component: Index,</span><br><span class=\"line\">            beforeEnter: (to, from, next) &#x3D;&gt; &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<h4 id=\"beforeleave\"><a class=\"markdownIt-Anchor\" href=\"#beforeleave\">#</a> beforeLeave</h4>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\">export default new Router (&#123;</span><br><span class=\"line\">    routes: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            path: &#39;&#x2F;index&#39;,</span><br><span class=\"line\">            component: Index,</span><br><span class=\"line\">            beforeLeave: (to, from, next) &#x3D;&gt; &#123;</span><br><span class=\"line\">            </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<h3 id=\"组件内路由钩子\"><a class=\"markdownIt-Anchor\" href=\"#组件内路由钩子\">#</a> 组件内路由钩子</h3>\n<ul>\n<li>\n<h4 id=\"beforerouteenter-进入这个组件路由之前\"><a class=\"markdownIt-Anchor\" href=\"#beforerouteenter-进入这个组件路由之前\">#</a> beforeRouteEnter: 进入这个组件路由之前</h4>\n<h4 id=\"beforerouteleave离开这个组件路由\"><a class=\"markdownIt-Anchor\" href=\"#beforerouteleave离开这个组件路由\">#</a> beforeRouteLeave：离开这个组件路由</h4>\n<h4 id=\"beforerouteupdate在本路由的下级路由切换才会触发beforerouteupdate\"><a class=\"markdownIt-Anchor\" href=\"#beforerouteupdate在本路由的下级路由切换才会触发beforerouteupdate\">#</a> beforeRouteUpdate：在本路由的下级路由切换才会触发 beforeRouteUpdate</h4>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">JS</span><br><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div&gt;</span><br><span class=\"line\">        测验：&#123;&#123;zst&#125;&#125;</span><br><span class=\"line\">    &lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;template&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    export default &#123;</span><br><span class=\"line\">        data()&#123;</span><br><span class=\"line\">            return &#123;</span><br><span class=\"line\">                zst:&#39;廾匸改变之前&#39;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        beforeCreate()&#123; &#x2F;&#x2F;组件生命周期函数</span><br><span class=\"line\">            console.log(&#39;创建之前&#39;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#x2F;&#x2F;进入组件之前，执行 beforRouteEnter </span><br><span class=\"line\">        beforeRouteEnter(to,from,next)&#123;</span><br><span class=\"line\">            console.log(&#39;123&#39;)</span><br><span class=\"line\">            console.log(this) &#x2F;&#x2F; 结果为undefined，因为在执行beforRouteEnter时候，组件还没有被创建出来，得先执行beforRouteEnter，再执行beforeCreate</span><br><span class=\"line\">            next((gx)&#x3D;&gt;&#123; &#x2F;&#x2F;参数gx就是当前组件的实例</span><br><span class=\"line\">                gx.zst &#x3D; &#39;被改变了&#39;</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        beforeRouteUpdate(to,from,next)&#123;</span><br><span class=\"line\">            console.log(&#39;abc&#39;)</span><br><span class=\"line\">            next()</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        beforeRouteLeave(to,from,next)&#123;&#x2F;&#x2F;离开组件的时候触发</span><br><span class=\"line\">            &#x2F;&#x2F;什么都不写的时候，走下一步</span><br><span class=\"line\">            next()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "Vue"
            ]
        }
    ]
}